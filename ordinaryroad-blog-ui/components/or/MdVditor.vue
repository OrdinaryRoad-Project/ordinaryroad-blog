<!--
  - MIT License
  -
  - Copyright (c) 2021 ËãóÈî¶Ê¥≤
  -
  - Permission is hereby granted, free of charge, to any person obtaining a copy
  - of this software and associated documentation files (the "Software"), to deal
  - in the Software without restriction, including without limitation the rights
  - to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  - copies of the Software, and to permit persons to whom the Software is
  - furnished to do so, subject to the following conditions:
  -
  - The above copyright notice and this permission notice shall be included in all
  - copies or substantial portions of the Software.
  -
  - THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  - IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  - FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  - AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  - LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  - OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  - SOFTWARE.
  -->

<template>
  <div ref="vditor" />
</template>

<script>
import Vditor from 'vditor'
import 'vditor/src/assets/less/index.less'

export default {
  name: 'OrMdVditor',
  components: {},
  props: {
    placeholder: {
      type: String,
      default: ''
    },
    commentMode: {
      type: Boolean,
      default: false
    },
    readOnly: {
      type: Boolean,
      default: true
    },
    preSetContent: {
      type: String,
      default: ''
    },
    dark: {
      type: Boolean,
      default: false
    },
    lang: {
      type: String,
      default: 'zh-Hans'
    },
    /**
     * ËÆ°ÁÆóÊ†áÈ¢òÂá∫Áé∞Êó∂Âà∞È°∂ÈÉ®ÁöÑÂÅèÁßªÈáè
     */
    headingsOffsetTop: {
      type: Number,
      default: 0
    }
  },
  data: () => ({
    scrollingOptions: {
      scrollEndTimer: null,
      currentScrollTop: 0
    },
    instance: undefined,
    headingElements: []
  }),
  watch: {
    lang (val) {
      try {
        if (this.readOnly) {
          this.updatePreviewerLang(val)
        } else {
          this.updateEditorLang(val)
        }
      } catch (e) {
      }
    },
    dark (val) {
      try {
        if (this.readOnly) {
          this.updatePreviewerTheme(val)
        } else {
          this.updateEditorTheme(val)
        }
      } catch (e) {
      }
    },
    placeholder (val) {
      try {
        this.setPlaceholder(val)
      } catch (e) {
      }
    }
  },
  created () {
  },
  // Áõ∏ÂΩì‰∫écreated‰∏≠ÁöÑnextTickÔºåÊ≠§Êó∂domÂÖÉÁ¥†Â∑≤ÁªèÊ∏≤ÊüìÂÆåÊàê
  mounted () {
    // ÂΩìÊü•ÁúãÂçöÂÆ¢ÔºåÊñ∞Âª∫ÂçöÂÆ¢ÁöÑÊó∂ÂÄôËß¶ÂèëmountedÊñπÊ≥ï
    if (this.readOnly) {
      this.initPreviewer(this.preSetContent)
    } else {
      this.initEditor()
    }
  },
  beforeDestroy () {
  },
  destroyed () {
    window.removeEventListener('scroll', this.handleScroll, false)
  },
  methods: {
    focus () {
      this.instance && this.instance.focus()
    },
    blur () {
      this.instance && this.instance.blur()
    },
    setPlaceholder (val) {
      if (!this.readOnly) {
        const byClassName = this.$refs.vditor.getElementsByClassName('vditor-reset')
        if (byClassName && byClassName.length > 0) {
          byClassName[0].setAttribute('placeholder', val)
        }
      }
    },
    setValue (val) {
      // console.log('watch:preSetContent', this.preSetContent)
      // // ÂΩìÁºñËæëÂçöÂÆ¢ÁöÑÊó∂ÂÄôËß¶ÂèëwatchÂíåmountedÊñπÊ≥ïÔºå‰ΩÜÊòØÂè™ÊúâÂú®watch‰∏≠ÊâçÊúâÂÄºÔºåÂõ†‰∏∫propÂºÇÊ≠•
      if (this.readOnly) {
        // this.initPreviewer(val)
      } else {
        const current = this.instance.getValue()
        // console.log(current === val)
        if (current !== val) {
          this.instance.setValue(val || '')
          this.$nextTick(() => {
            if (!this.commentMode) {
              // this.instance.focus()
            }
          })
        }
        // this.initEditor(null)
      }
    },
    updateEditorLang (lang) {
      // todo
      if (this.instance) {
        // this.instance.destroy()
        // this.initEditor()
      }
    },
    updateEditorTheme (dark) {
      if (this.instance) {
        let editorTheme = 'classic'
        let theme = 'light'
        let codeTheme = 'github'
        if (dark) {
          editorTheme = 'dark'
          theme = 'dark'
          codeTheme = 'dracula'
        }
        this.instance.setTheme(editorTheme, theme, codeTheme)
      }
    },
    updatePreviewerLang (lang) {
      // todo
    },
    updatePreviewerTheme (dark) {
      // TODO Â§úÈó¥Ê®°ÂºèÈìæÊé•È¢úËâ≤‰∏çÂØπ
      let theme = 'light'
      let codeTheme = 'github'
      if (dark) {
        theme = 'dark'
        codeTheme = 'dracula'
      }
      Vditor.setCodeTheme(codeTheme)
      const vditorVersion = require('@/package.json').dependencies.vditor.replace('^', '@')
      Vditor.setContentTheme(theme, `https://unpkg.com/vditor${vditorVersion}/dist/css/content-theme`)
    },
    initEditor () {
      this.instance = new Vditor(this.$refs.vditor, {
        lang: this.lang === 'en' ? 'en_US' : 'zh_CN',
        placeholder: this.placeholder,
        toolbarConfig: {
          hide: this.commentMode,
          pin: true
        },
        // https://b3log.org/vditor/demo/advanced-hint.html
        hint: {
          emojiTail: 'ËæìÂÖ•Ëã±ÊñáÂÜíÂè∑ <code>:</code> ‰ΩøÁî®<a href="https://github.com/88250/lute/blob/master/parse/emoji_map.go" target="_blank">Êõ¥Â§öË°®ÊÉÖ</a>Ôºà<a href="https://www.emojiall.com/zh-cn" target="_blank">emojiall</a>Ôºâ',
          // https://github.com/88250/lute/blob/master/parse/emoji_map.go?utm_source=ld246.com
          emoji: {
            '+1': 'üëç',
            '-1': 'üëé',
            heart: '‚ù§',
            cold_sweat: 'üò∞',
            sad: 'üíî'
            // 'or-logo': 'https://cdn.jsdelivr.net/npm/vditor@1.3.1/dist/images/emoji/j.png'
          },
          extend: [
            {
              key: '@',
              hint (value) {
                console.log(value)
                return [
                  {
                    html: '<a> 1 </a>',
                    value: '@1'
                  }
                ]
              }
            }
          ]
        },
        minHeight: this.commentMode ? 50 : 600,
        value: this.preSetContent || '',
        mode: 'wysiwyg',
        theme: this.dark ? 'dark' : 'classic',
        icon: 'material',
        counter: {
          type: 'text',
          enable: true
        },
        cache: {
          enable: false
        },
        preview: {
          hljs: {
            style: this.dark ? 'dracula' : 'github',
            lineNumber: true
          },
          theme: {
            current: this.dark ? 'dark' : 'light'
          }
        },
        upload: {
          max: 30 * 1024 * 1024,
          url: '/api/blog/common/upload',
          // Ë∑®Á´ôÁÇπËÆøÈóÆÊéßÂà∂„ÄÇÈªòËÆ§ÂÄº: false
          withCredentials: true,
          headers: {},
          // ÊòØÂê¶ÂÖÅËÆ∏Â§öÊñá‰ª∂‰∏ä‰º†„ÄÇÈªòËÆ§ÂÄºÔºötrue
          multiple: false,
          fieldName: 'file',
          setHeaders: () => {
            return {
              'or-blog-token': this.$store.getters['user/getTokenValue']
            }
          },
          // linkToImgUrl: '/blog/upload/{url}',
          // linkToImgFormat: (responseText) => {
          //   const response = JSON.parse(responseText)
          //   response.code = 0
          //   response.msg = ''
          //   const url = response.data.url
          //   response.data.url = this.$constants.OSS_INFO.download + url
          //   // console.log(response)
          //   return JSON.stringify(response)
          // },
          format: (files, responseText) => {
            // console.log(files, responseText)
            const file = files[0]
            const response = {}
            response.code = 0
            response.msg = ''
            response.data = { succMap: {} }
            // const succMap = response.data.succMap
            // const succMapNew = {}
            response.data.succMap[file.name] = `${this.$config.FILE_DOWNLOAD_BASE_URL}${responseText}`
            // console.log(response)
            return JSON.stringify(response)
          }
        },
        resize: {
          enable: true
        },
        outline: {
          enable: !this.commentMode
        },
        after: () => {
          this.updateEditorTheme(this.dark)
          this.$nextTick(() => {
            if (this.commentMode) {
              // ËØÑËÆ∫ÁöÑÊó∂ÂÄôËÆæÁΩÆpadding
            } else {
              // this.instance.focus()
            }
          })
          this.$emit('after', 'edit')
        },
        input: (value) => {
          this.$emit('update:transferContent', value)
        },
        focus: (value) => {
          this.$emit('focus')
        },
        blur: (value) => {
          this.$emit('blur')
        }
      })
    },
    initPreviewer (content) {
      const previewElement = this.$refs.vditor
      // const renderHeading = false
      // const textTemp = ''
      if (this.commentMode) {
        previewElement.style.paddingLeft = '0'
        previewElement.style.paddingRight = '0'
      } else {
        previewElement.style.paddingLeft = '20px'
        previewElement.style.paddingRight = '20px'
      }
      let mode = 'light'
      let theme = 'light'
      let codeTheme = 'github'
      if (this.dark) {
        mode = 'dark'
        theme = 'dark'
        codeTheme = 'dracula'
      }
      Vditor.preview(previewElement, content,
        {
          lang: this.lang === 'en' ? 'en_US' : 'zh_CN',
          markdown: {
            autoSpace: true,
            paragraphBeginningSpace: true,
            toc: false,
            fixTermTypo: true
          },
          mode,
          hljs: {
            style: codeTheme,
            lineNumber: true
          },
          anchor: 1,
          theme: {
            current: theme
          },
          icon: 'material',
          speech: {
            enable: true
          },
          renderers: {
            // renderText: (node, entering) => {
            //   if (entering) {
            //     if (textTemp === '' && renderHeading) {
            //       textTemp = node.TokensStr()
            //       renderHeading = false
            //     }
            //     return ['', Lute.WalkContinue]
            //   } else {
            //     return [node.TokensStr(), Lute.WalkContinue]
            //   }
            // },
            // renderHeading: (node, entering) => {
            //   if (entering) {
            //     renderHeading = true
            //     return [`<div><h${node.__internal_object__.HeadingLevel}>`, Lute.WalkContinue];
            //   } else {
            //     let string = `</h${node.__internal_object__.HeadingLevel}><div name="${textTemp}"></div></div>`;
            //     textTemp = '';
            //     return [string, Lute.WalkContinue];
            //   }
            // }
          },
          after: () => {
            this.updatePreviewerTheme(this.dark)
            previewElement.addEventListener('click', (event) => {
              if (event.target.tagName === 'IMG') {
                Vditor.previewImage(event.target, this.$i18n.locale === 'en' ? 'en_US' : 'zh_CN', this.$vuetify.theme.dark ? 'dark' : 'light')
              }
            })

            if (this.commentMode) {
              // ËØÑËÆ∫‰∏çÈúÄË¶ÅÁõÆÂΩï
              return
            }

            // Êó†Êïà
            // Vditor.outlineRender(
            //   previewElement,
            //   document.getElementById('outline')
            // )
            // console.log(previewElement.querySelectorAll('h1,h2,h3,h4,h5,h6'));
            const elementNodeListOf = previewElement.querySelectorAll('h1,h2,h3,h4,h5,h6')
            if (elementNodeListOf.length && elementNodeListOf.length > 0) {
              const toc = []
              const headingElements = []
              for (let i = 0; i < elementNodeListOf.length; i++) {
                const element = elementNodeListOf[i]
                headingElements.push(element)
                element.setAttribute('id', 'h' + '-' + i)
                // console.log(element.tagName.charAt(1))
                // console.log(element.textContent)
                // console.log('\n')

                let headString
                let headHtml = element.innerHTML
                const vditorAnchor = element.getElementsByTagName('a')
                if (vditorAnchor && vditorAnchor[vditorAnchor.length - 1]) {
                  headString = vditorAnchor[vditorAnchor.length - 1].getAttribute('id').slice(13)
                  headHtml = headHtml.replace(vditorAnchor[vditorAnchor.length - 1].outerHTML, '')
                } else {
                  headString = element.textContent
                }

                toc.push({
                  id: i,
                  index: element.tagName.charAt(1) - 1,
                  headString,
                  headHtml
                })
              }
              this.$emit('update:previewToc', toc)
              // console.log('toc', toc)

              this.$emit('update:currentTocIndex', 0)
              // console.log('MdVditor ÈúÄË¶ÅÊøÄÊ¥ªÁöÑÁõÆÂΩï', 0)

              this.headingElements = headingElements

              window.addEventListener('scroll', this.handleScroll)
            }

            this.$emit('after', 'preview')
          }
        }
      )
    },
    handleScroll () {
      const headingElements = this.headingElements
      // ÂèëÁîüÊªöÂä®ÈáçÁΩÆËÆ°Êó∂Âô®
      clearTimeout(this.scrollingOptions.scrollEndTimer)
      this.scrollingOptions.currentScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
      // 100msÂêéË∞ÉÁî®ÂáΩÊï∞Âà§Êñ≠t1,t2ÊòØÂê¶‰∏ÄËá¥
      this.scrollingOptions.scrollEndTimer = setTimeout(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
        if (this.scrollingOptions.currentScrollTop === scrollTop) {
          // console.log("ÊªöÂä®ÁªìÊùü")
          let currentTocIndex = headingElements.length - 1
          for (let i = 0; i < headingElements.length; i++) {
            // ÊâæÂà∞ Â±èÂπï‰∏ä Á¶ªoffsetÊúÄËøëÁöÑ ÂÖÉÁ¥†
            const offset = this.headingsOffsetTop
            const element = headingElements[i]
            const currentTop = element.getBoundingClientRect().top
            // console.log(offset, currentTop)
            if (currentTop >= offset) {
              if (currentTop - offset <= 1) {
                currentTocIndex = i
                // console.log('MdVditor ÊªëÂä®ÂêéÈúÄË¶ÅÊøÄÊ¥ªÁöÑÁõÆÂΩï', i)
              } else if (i > 1) {
                const preElement = headingElements[i - 1]
                const preTop = preElement.getBoundingClientRect().headingsOffsetTop
                const distance = currentTop - preTop
                if (distance < offset) {
                  // Èó¥Ë∑ùËøáÂ∞èÔºåÁõ¥Êé•ËÆæÁΩÆÂΩìÂâçÁöÑ‰ΩçÁΩÆ
                  currentTocIndex = i
                  // console.log('MdVditor ÊªëÂä®ÂêéÈúÄË¶ÅÊøÄÊ¥ªÁöÑÁõÆÂΩï distance < offset', i)
                } else if (currentTop - offset < 3) {
                  // ÂΩìÂâçÁ¥ßÈù†offset‰ΩçÁΩÆ
                  currentTocIndex = i
                  // console.log('MdVditor ÊªëÂä®ÂêéÈúÄË¶ÅÊøÄÊ¥ªÁöÑÁõÆÂΩï currentTop - offset < 3', i)
                } else {
                  // ‰∏ä‰∏ÄÈÉ®ÂàÜËøòÊ≤°ÂÆåÂÖ®ÈÅÆ‰Ωè
                  currentTocIndex = i - 1
                  // console.log('MdVditor ÊªëÂä®ÂêéÈúÄË¶ÅÊøÄÊ¥ªÁöÑÁõÆÂΩï', i - 1)
                }
              } else {
                currentTocIndex = 0
              }
              break
            }
          }
          this.$emit('update:currentTocIndex', currentTocIndex)
        }
      }, 100)
    }
  }
}
</script>

<style>
.vditor-img {
  z-index: 100;
  /*margin: 80px;*/
}

.vditor-toolbar--hide {
  display: none;
}
</style>
